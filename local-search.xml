<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>spring的并发问题</title>
    <link href="/2023/08/10/spring%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/10/spring%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p> 有一天我突然有疑惑，我使用spring的时候，分明是普通编程，为什么它不会产生并发安全问题呢</p><p>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。<br>那么对于有状态的bean呢？Spring对一些（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态的bean采用ThreadLocal进行处理，让它们也成为线程安全的状态，因此有状态的Bean就可以在多线程中共享了。</p><p><strong>如果用有状态的bean，也可以使用用prototype模式，每次在注入的时候就重新创建一个bean，在多线程中互不影响。</strong></p><p>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。</p><p>无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象  .不能保存数据，是不变类，是线程安全的。</p><p>无状态的Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。</p><p>有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。</p><p>Servlet体系结构是建立在Java多线程机制之上的，它的生命周期是由Web 容器负责的。一个Servlet类在Application中只有一个实例存在，也就是有多个线程在使用这个实例。这是单例模式的应用。如Service层、Dao层用默认singleton就行，虽然Service类也有dao这样的属性，但dao这些类都是没有状态信息的，也就是相当于不变(immutable)类，所以不影响。Struts2中的Action因为会有User、BizEntity这样的实例对象，是有状态信息的，在多线程环境下是不安全的，所以Struts2默认的实现是Prototype模式。在Spring中，Struts2的Action中，scope要配成prototype作用域。 （单例模式-单例注册表实现和threadLocal-可以处理有状态的bean之间的关系）</p><p>还有我们的实体bean，从客户端传递到后台的controller–&gt;service–&gt;Dao,这一个流程中，他们这些对象都是单例的，那么这些单例的对象在处理我们的传递到后台的实体bean不会出问题吗？<br>答：[实体bean不是单例的]，并没有交给spring来管理，每次我们都手动的New出来的【如EMakeType et &#x3D; new EMakeType();】，所以即使是那些处理我们提交数据的业务处理类是被多线程共享的，但是他们处理的数据并不是共享的，数据时每一个线程都有自己的一份，所以在数据这个方面是不会出现线程同步方面的问题的。</p><p><strong>（在这里补充下自己在项目开发中对于实体bean在多线程中的处理：1。对于实体bean一般通过方法参数的的形式传递（参数是局部变量），所以多线程之间不会有影响。2.有的地方对于有状态的bean直接使用prototype原型模式来进行解决。3.对于使用bean的地方可以通过new的方式来创建）</strong></p><p>但是那些的在Dao中的xxxDao,或controller中的xxxService，这些对象都是单例那么就会出现线程同步的问题。但是话又说回来了，这些对象虽然会被多个进程并发访问，可我们访问的是他们里面的方法，<strong>这些类里面通常不会含有成员变量</strong>，那个Dao里面的ibatisDao是框架里面封装好的，已经被测试，不会出现线程同步问题了。所以出问题的地方就是我们自己系统里面的业务对象，<strong>所以我们一定要注意这些业务对象里面千万不能要独立成员变量</strong>，否则会出错。</p><p>spring对那些个有状态bean使用ThreadLocal维护变量[仅仅是变量,因为线程同步的问题就是成员变量的互斥访问出问题]时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p><strong>对spring并发访问线程安全的两篇博客汇总，可以得出上述结论…………..</strong></p><p>由于Spring MVC默认是Singleton的，所以会产生一个潜在的安全隐患。根本核心是instance<strong>的变量保持状态</strong>的问题。这意味着每个request过来，系统都会用原有的instance去处理，这样导致了两个结果（单例的好处）：</p><p>一是我们不用每次创建Controller，<br>二是减少了对象创建和垃圾收集的时间；<br>由于只有一个Controller的instance，当多个线程同时调用它的时候，它里面的instance<strong>变量</strong>（可以理解为私有变量）就不是线程安全的了，会发生窜数据的问题。<br>当然大多数情况下，我们根本不需要考虑线程安全的问题，比如dao,service等，除非在bean中声明了实例变量。因此，我们在使用spring mvc 的contrller时，<strong>应避免在controller中定义实例变量（singleton唯一的不好是单例的变量容易出现问题，下面有解决的方案）</strong>。<br>如：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">publicclassControllerextendsAbstractCommandController&#123;<br><span class="hljs-params">...</span><span class="hljs-params">...</span><br>protectedModelAndView <span class="hljs-keyword">handle</span>(HttpServletRequest request,HttpServletResponse response,<br>Object command,BindException errors)throwsException&#123;<br>company =<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.;<br>&#125;<br>protectedCompany company;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里有声明一个变量company，这里就存在并发线程安全的问题。<br>如果控制器是使用单例形式，且controller中有一个私有的变量a,所有请求到同一个controller时，使用的a变量是共用的，即若是某个请求中修改了这个变量a，则，在别的请求中能够读到这个修改的内容。。</p><p><strong>有几种解决方法：</strong><br>1、在控制器中不使用实例变量（可以使用方法参数的形式解决，参考博文<a href="http://blog.csdn.net/cs408/article/details/47809271"> Spring Bean Scope 有状态的Bean 无状态的Bean</a>）<br>2、将控制器的作用域从单例改为原型，即在spring配置文件Controller中声明 scope&#x3D;”prototype”，每次都创建新的controller<br>3、在Controller中使用ThreadLocal变量</p><p>这几种做法有好有坏，第一种，需要开发人员拥有较高的编程水平与思想意识，在编码过程中力求避免出现这种BUG，</p><p>而第二种则是容器自动的对每个请求产生一个实例，由JVM进行垃圾回收，因此做到了线程安全。</p><p>使用第一种方式的好处是实例对象只有一个，所有的请求都调用该实例对象，速度和性能上要优于第二种，不好的地方，就是需要程序员自己去控制实例变量的状态保持问题。第二种由于每次请求都创建一个实例，所以会消耗较多的内存空间。</p><p>所以在使用spring开发web 时要注意，默认Controller、Dao、Service都是单例的。</p><p>【1】SpringMVC多线程环境中如何保证对象的安全性？</p><p>代码如下：</p><p>@RequestMapping(“&#x2F;user”) @Controller ClassUserController { @Resource UserService userService; @RequestMapping(“&#x2F;add”) publicvoid testA(User user){ userService.add(user); } @RequestMapping(“&#x2F;get”) publicvoid testA(int id){ userService.get(id); } } @Service(“userService”) ClassUserService{ publicstaticMap&lt;Integer,User&gt; usersCache &#x3D;newHashMap&lt;String,User&gt;(); publicvoid add(User user){ usersCache.put(user.getId(),user); } publicvoidget(int id){ usersCache.get(id); } }</p><p>此段代码，usersCache对象就是线程不安全的。因为它是静态的全局共享对象。如果有多个线程同时调用add方法，可能会发生用户对象被覆盖的情况，也就是id对应对象不一致，这是多线程编程中最常发生的事情。</p><p>所以，可以使用 Collections 工具同步Map。</p><p>static Map&lt;Integer, Users&gt; usersCache &#x3D; Collections.synchronizedMap(new HashMap&lt;Integer, Users&gt;());</p><p>研究一下，Spring中的源码，它对常用的开源框架做了大量封装，如， Hibernate中的sessionFactory，就使用的是 org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean，而在 AnnotationSessionFactoryBean的父类LocalSessionFactoryBean中，定义了大量的ThreadLocal来保证多线程的安全性。 </p><p>publicclassLocalSessionFactoryBeanextendsAbstractSessionFactoryBeanimplementsBeanClassLoaderAware{ privatestaticfinalThreadLocal<DataSource> configTimeDataSourceHolder &#x3D; newThreadLocal<DataSource>(); privatestaticfinalThreadLocal<TransactionManager> configTimeTransactionManagerHolder &#x3D; newThreadLocal<TransactionManager>(); privatestaticfinalThreadLocal<Object> configTimeRegionFactoryHolder &#x3D; newThreadLocal<Object>(); privatestaticfinalThreadLocal<CacheProvider> configTimeCacheProviderHolder &#x3D; newThreadLocal<CacheProvider>(); privatestaticfinalThreadLocal<LobHandler> configTimeLobHandlerHolder &#x3D; newThreadLocal<LobHandler>();</p><p>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法的思考</title>
    <link href="/2023/08/10/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%80%83%20(2)/"/>
    <url>/2023/08/10/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%80%83%20(2)/</url>
    
    <content type="html"><![CDATA[<p>前言：算法菜鸡的练习之旅。</p><h2 id="第一天的整理"><a href="#第一天的整理" class="headerlink" title="第一天的整理"></a>第一天的整理</h2><h3 id="一，合并有序数（leetcode88）"><a href="#一，合并有序数（leetcode88）" class="headerlink" title="一，合并有序数（leetcode88）"></a>一，合并有序数（leetcode88）</h3><p><strong>心得</strong>：我听了一节二分法的课再开始刷题的，谈及边界的时候，他特别强调，你要知道自己的变量代表什么，你才知道循环条件是什么。一个重要思想是：<strong>你要知道自己的变量代表什么，你才知道循环条件是什么。写的时候问自己，这个边界在下一个循环中是被排除的吗？</strong></p><p>法一：双指针。空间，时间复杂度On。</p><p>​使用临时数组来排序。</p><p>​<strong>不熟练的点</strong>：int[]和arraylist<Integer>的相互转变</p><p>法二：逆序双指针。时间On，空间O1.</p><p>​因为第一个数组是比较大的，所以可以逆序，从后往前，不断挑选最大的数字加入。</p><p>​<strong>不熟练的点</strong>：循环条件，临时变量的设置，指针移动导致的<strong>边界问题</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1 == -<span class="hljs-number">1</span>)&#123;<br>                cur = nums2[p2];<br>                p2--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( p2 == -<span class="hljs-number">1</span> )&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( nums1[p1] &gt; nums2[p2] )&#123;<br>                cur = nums1[p1];<br>                p1--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( nums1[p1] &lt;= nums2[p2] )&#123;<br>                cur = nums2[p2];<br>                p2--;<br>            &#125;<br>            nums1[tail] = cur;<br>            tail--;<br>        &#125;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>法三：合并并快排。空间O1，时间Onlogn</p><p>​<strong>不熟练</strong>的点：库函数使用不熟练。合并和快排都不会。</p><h3 id="二，移除元素（力扣27）"><a href="#二，移除元素（力扣27）" class="headerlink" title="二，移除元素（力扣27）"></a>二，移除元素（力扣27）</h3><p>简单双指针。</p><h3 id="三，删除有序数重复项（力扣25）"><a href="#三，删除有序数重复项（力扣25）" class="headerlink" title="三，删除有序数重复项（力扣25）"></a>三，删除有序数重复项（力扣25）</h3><p>简单双指针</p><h3 id="四，删除有序数重复项Ⅱ（力扣80）"><a href="#四，删除有序数重复项Ⅱ（力扣80）" class="headerlink" title="四，删除有序数重复项Ⅱ（力扣80）"></a>四，删除有序数重复项Ⅱ（力扣80）</h3><p><strong>心得</strong>：它的边界令我心碎，东一个补丁，西一个补丁。写代码之前要注意思路，脑海里模拟随着循环指针的行进。特别注意一个0个，所有全插入，所有后插入等等情况。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk">给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。<br><br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(<span class="hljs-number">1</span>) 额外空间的条件下完成。<br><br> <br>说明：<br><br>为什么返回数值是整数，但输出的答案是数组呢？<br><br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br><br>你可以想象内部操作如下:<br><br><span class="hljs-regexp">//</span> nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);<br><br><span class="hljs-regexp">//</span> 在函数里修改输入数组对于调用者是可见的。<br><span class="hljs-regexp">//</span> 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    print(nums[i]);<br>&#125;<br><br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>解释：函数应返回新长度 length = <span class="hljs-number">5</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> 。 不需要考虑数组中超出新长度后面的元素。<br>示例 <span class="hljs-number">2</span>：<br><br>输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">7</span>, nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>解释：函数应返回新长度 length = <span class="hljs-number">7</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span> 。 不需要考虑数组中超出新长度后面的元素。<br><br>来源：力扣（LeetCode）<br>链接：https:<span class="hljs-regexp">//</span>leetcode.cn<span class="hljs-regexp">/problems/</span>remove-duplicates-from-sorted-array-ii<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>我写的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">before</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flagOnce</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">while</span> (before &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[front] == nums[before]) &#123;<br>                sum++;<br>                <span class="hljs-keyword">if</span> (sum &lt;= <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(flagOnce)&#123;<br>                        flagOnce = <span class="hljs-literal">false</span>;<br>                        nums[front] = nums[before];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        front++;<br>                        nums[front] = nums[before];<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum = <span class="hljs-number">1</span>;<br>                front++;<br>                nums[front] = nums[before];<br>            &#125;<br>            before++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> front + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二天的整理"><a href="#第二天的整理" class="headerlink" title="第二天的整理"></a>第二天的整理</h2><h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h3><p>心得：相较于第一天的练习我只能说长进太少了，下次要开始编写代码之前，一定要把昨天的整理复习一遍再开始。</p><p>这道题打开我思路就是hashamap给它记录下来。但其实是脑经急转弯一般的题目，思考方式一是记录，二是相互碰撞相消，三是排序。</p><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1：</p><p>输入：nums &#x3D; [3,2,3]<br>输出：3<br>示例 2：</p><p>输入：nums &#x3D; [2,2,1,1,1,2,2]<br>输出：2</p><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h3><p>简单dp</p><h3 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274. H 指数"></a><a href="https://leetcode.cn/problems/h-index/">274. H 指数</a></h3><p>心得：简单题目。练习了，Arrays的方法，HashMap的方法。注意：Array，HashMap使用不是很熟练</p><h3 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h3><p>心得：同上。但是第一次我没有直接运行起来，原因是我在写代码的时候，思考过程中漏洞百出，推理出的流程根本无法实现功能。</p><h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode.cn/problems/roman-to-integer/">13. 罗马数字转整数</a></h3><p>心得：对字符串的stringbuffer等非常不熟练。思考过程中忽略了正则表达式。思考过程中忽略了hashMap的特性。</p><p>问题：string 为什么又有length()括号 switchcase语法</p><p>​</p><h2 id="第三天的整理"><a href="#第三天的整理" class="headerlink" title="第三天的整理"></a>第三天的整理</h2><h3 id="lambda表达式和排序练习"><a href="#lambda表达式和排序练习" class="headerlink" title="lambda表达式和排序练习"></a>lambda表达式和排序练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomObjectSorting</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建自定义对象的 ArrayList</span><br>        ArrayList&lt;Person&gt; people = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        people.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>));<br>        people.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">30</span>));<br>        people.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">20</span>));<br><br>        <span class="hljs-comment">// 使用 Collections 排序 ArrayList</span><br>        Collections.sort(people, (person1, person2) -&gt; Integer.compare(person2.getAge(),person1.getAge()));<br><br>        <span class="hljs-comment">// 输出排序后的结果</span><br>        <span class="hljs-keyword">for</span> (Person person : people) &#123;<br>            System.out.println(person.getName() + <span class="hljs-string">&quot; - &quot;</span> + person.getAge());<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Collections.binarySearch(people,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">20</span>),(p1,p2)-&gt;  Integer.compare(p2.getAge(),p1.getAge()));<br>        System.out.println(index);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    Person(String name,<span class="hljs-type">int</span> age)&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="字符转换int"><a href="#字符转换int" class="headerlink" title="字符转换int"></a>字符转换int</h3><h3 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode.cn/problems/integer-to-roman/">12. 整数转罗马数字</a></h3><p>心得：力扣无法使用正则表达式的东西，所以我再IDE写了，之后就开始看答案了。这是不对的，我应该挣扎一下，思考其他思路。</p><p>最后写法：</p><ol><li>正则表达式</li><li>关键点存储，每次判断num大于关键点就加一个数字</li><li>纯纯每个十位都写上所有情况，一共写三十个位的二维数组记录。</li></ol><h2 id="第四天的练习"><a href="#第四天的练习" class="headerlink" title="第四天的练习"></a>第四天的练习</h2><h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a href="https://leetcode.cn/problems/length-of-last-word/">58. 最后一个单词的长度</a></h3><p>简单的字符串处理</p><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></h3><p>简单的字符串处理</p><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h3><p>简单的字符串处理。</p><h2 id="第五天的练习"><a href="#第五天的练习" class="headerlink" title="第五天的练习"></a>第五天的练习</h2><p>今天没有练习，晚上学习一下多线程。</p><p>最终还是没有学习，晚上打农去了</p><h2 id="第六天的练习"><a href="#第六天的练习" class="headerlink" title="第六天的练习"></a>第六天的练习</h2><p>​kmp算法，如何理解next呢？</p><p>​aabaabaaf中匹配aabaaf。当在第二个b不匹配的时候，</p><ol><li>证明aabaa是匹配的，那么aabaa不行，就只能尽可能找最长的和后缀相同的前缀位置。</li><li>aa是next能找到的最多的匹配位置。</li><li>那么为什么能找到aa呢？因为aabaaf中，f寄了，aabaa相同，但是不能用，但可以说明aa可以找到。</li></ol><p>二如何求得next数组。next数组的意思是例如aabaaf。</p><ol><li>如果长度为1，前后缀匹配最长0</li><li>为2，~1</li><li>为3，~0</li><li>为4，1</li><li>为5，2</li><li>为6，0；</li><li>故数组为0，1，0，1，2，0；</li></ol><p>编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span> []next , String s)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//前缀末尾下表</span><br>       next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>           <br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; s.length() ; i++)&#123;<br>           <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j))&#123;<br>               j = next[j - <span class="hljs-number">1</span>];<br>           &#125;<br>           <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>               j++;<br>           &#125;<br>           next[i] = j;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第七天的练习"><a href="#第七天的练习" class="headerlink" title="第七天的练习"></a>第七天的练习</h2><h3 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68. 文本左右对齐"></a><a href="https://leetcode.cn/problems/text-justification/">68. 文本左右对齐</a></h3><p>stringBuffer 的add ，append ，length，insert。</p><p>list的add ，append ，length，insert</p><p>list没有append，没有insert，集成到add里了</p><p>sb没有add</p><p>string[]的长度没有括号<br>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，把我写的要死要活。</p><p>我分的情况是下一个单词不要要换行，刚刚好长度，要换行。<br>我的想法：</p><ol><li>不要换行，那就加单词空格，直到换行</li><li>刚刚好，那就直接上到res</li><li>要换行，那就品鉴一下是否加空格（？？）坑定要加啊</li></ol><p>加单词空格我也有问题：</p><ol><li>直接就除余，不整除就多一个空格。（真的大聪明）。</li></ol><p>然后我美美开始写。</p><p>得到一大坨垃圾代码，出现的问题有，临时变量生命周期管理不明确马，导致初始化问题。<strong>临时变量尽量生命周期尽量短</strong></p><p>想法出错：<strong>结束条件不明确。</strong>不换行的时候会结束，刚刚好会结束，要换行的时候会结束。导致代码极度混乱。各种if - else</p><h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h3><p>askI码和字符的关系，字符串大小写</p><h2 id="2023-x2F-7-x2F-13"><a href="#2023-x2F-7-x2F-13" class="headerlink" title="2023&#x2F;7&#x2F;13"></a>2023&#x2F;7&#x2F;13</h2><h3 id="字符串的替换和正则表达式"><a href="#字符串的替换和正则表达式" class="headerlink" title="字符串的替换和正则表达式"></a>字符串的替换和正则表达式</h3><h2 id="2023-x2F-7-x2F-14"><a href="#2023-x2F-7-x2F-14" class="headerlink" title="2023&#x2F;7&#x2F;14"></a>2023&#x2F;7&#x2F;14</h2><h3 id="双端队列和单调队列"><a href="#双端队列和单调队列" class="headerlink" title="双端队列和单调队列"></a>双端队列和单调队列</h3><h2 id="2023-x2F-7-x2F-18"><a href="#2023-x2F-7-x2F-18" class="headerlink" title="2023&#x2F;7&#x2F;18"></a>2023&#x2F;7&#x2F;18</h2><p>一连好几天没写日记沉淀。首先最重要的还是吧生活过好，才能好好学习。我的短视频和游戏瘾太重了。</p><h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h3><p>计数器思想，而不是按照顺序</p><p>自己写的代码：&#x2F;&#x2F;栈为空的时候，指针边界，循环最好从成功or失败打头。</p><p>当你发现你需要修改你for循环的长度的时候，不妨使用i–，因为终止条件是0，而初始化后i不变</p><h2 id="2023-x2F-7-x2F-19"><a href="#2023-x2F-7-x2F-19" class="headerlink" title="2023&#x2F;7&#x2F;19"></a>2023&#x2F;7&#x2F;19</h2><h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h3><p><strong>心得</strong>：这道题我没写出来，记得及时复习。三个节点怎么动的？循环的指针为什么取中间那个？</p><h3 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h3><p><strong>心得：</strong>这道题自己的思路有问题，看了大佬的思路才抄出来的。使用了map存储。也使用map的key作为索引，不是很明白这道题考察了什么。大概是逻辑推理能力把。</p><h3 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h3><p><strong>心得：</strong>一道很简单的题目，写的很心酸（虽然是几天之前的我写的），主要的点1.没有考虑删除第一个节点的情况，2.考虑之后返回head导致错误。</p><h3 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><p><strong>心得：</strong>第一道困难题，单调队列，了解原理之后其实不难，但是其中步骤也繁多，对<strong>下标</strong>不敏感，对<strong>先后顺序</strong>思考混乱，先删除后添加还是反之，<strong>res的添加时机</strong>等等，输出和预期结果不一致时的debug能力。</p><h3 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h3><p><strong>心得：</strong>循环条件导致，pop到空的时候我写的逻辑里面，空不了。这道题还有一个逆天的点位，完全等价的两个代码块会导致答案的不对，晚点一定要来解决。</p><h3 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h3><p><strong>心得：</strong>使用蛮力法逆天而为，虽然idea过了，但是力扣没给过，最适合的方法是边界缩小法。</p><h3 id="剑指-Offer-31-栈的压入、弹出序列-1"><a href="#剑指-Offer-31-栈的压入、弹出序列-1" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h3><p><strong>心得：</strong>使用指针模拟了栈的行为，写的很丑陋，是匹配，然后遍历弹出，然后弹出的各种情况，ifelse。。。大佬的思路就好的多，一次压一个，然后第二个数组匹配，能弹多少弹多少。最后计数，看看弹出的数量是否刚好。<strong>计数</strong>是一个很好的思路，不一定要判断空，要原来的数组怎么样。</p><h3 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3><p><strong>心得：</strong>自此进入二叉树，递归，dfs，bfs，回溯的世界！这道题的思想也是<strong>计数</strong>。当然可以往queue塞标记，但是哪里有计数方便呢。</p><h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h3><p><strong>心得：</strong>进入二叉树的世界，记住，有的<strong>递归就递归</strong>，别惦记你那普通方法，多记几个常规的递归。熟练写非递归方案的遍历。</p><p>今天一下子写的有些多，明天再总结，今天还有很多东西要搞</p><h3 id="剑指-Offer-12-矩阵中的路径-剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-12-矩阵中的路径-剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径 + 剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a> + <a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h3><p><strong>心得：dfs+递归+回溯</strong>，dfs的写法，一般先不考虑回溯的问题，只管按照1.退出条件。2确认条件。3.递归继续找。写完之后，要记得加入回溯。则得到套路</p><ol><li>退出条件</li><li>确认条件</li><li>标记</li><li>递归继续找</li><li>删除标记</li></ol><h3 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h3><p><strong>心得：</strong>当你手上武器有限的时候，要使用有限的武器来打倒题目。只有最大深度的方法，但是可以递归所有根来判断是否所有根都满足最大深度差不大于1.</p><h3 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h3><p><strong>心得</strong>：这道题蛮难，满<strong>新颖</strong>。<strong>递归+回溯</strong>的<strong>经典</strong>很难。同时出现递归的时候，解读他不仅仅是递归名字的意义，通过这道题，给我全新的解读和理解递归的角度。这道题，<strong>递归解读为上一个递归回溯回来的节点信息。</strong></p><h2 id="树的常见递归"><a href="#树的常见递归" class="headerlink" title="树的常见递归"></a>树的常见递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以某根开始的树的子结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sameTree</span><span class="hljs-params">(TreeNode A,TreeNode B)</span>&#123;<br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> A.val == B.val &amp;&amp; sameTree(A.left,B.left) &amp;&amp; sameTree(A.right,B.right);<br>    &#125;<br><br><span class="hljs-comment">//完全相同的树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sameTree</span><span class="hljs-params">(TreeNode A,TreeNode B)</span>&#123;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> &amp;&amp; B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> sameTree(A.left,B.right) &amp;&amp; sameTree(A.right,B.left);<br>    &#125;<br><br><span class="hljs-comment">//树的先序遍历</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">perOrder</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <br>    System.out.println(root.val());<br>    perOrder(root.left);<br>    perOrder(root.rigth);<br>&#125;<br><br><span class="hljs-comment">//树的非递归先序遍历</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">perOrder</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>   <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    stack.push(root);<br><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>        System.out.print(node.val + <span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) stack.push(node.right);<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) stack.push(node.left);<br>    &#125;   <br>&#125;<br><br><span class="hljs-comment">//中序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nonRecursiveInorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> root;<br><br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(curr);<br>            curr = curr.left;<br>        &#125;<br><br>        curr = stack.pop();<br>        System.out.print(curr.val + <span class="hljs-string">&quot; &quot;</span>);<br><br>        curr = curr.right;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//后序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nonRecursivePostorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    stack.push(root);<br>    Stack&lt;TreeNode&gt; output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> stack.pop();<br>        output.push(current);<br><br>        <span class="hljs-keyword">if</span> (current.left != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (current.right != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!output.isEmpty()) &#123;<br>        System.out.print(output.pop().val + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//二叉树的深度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">return</span> root == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : Math.max( maxDepth(root.left) + <span class="hljs-number">1</span>,maxDepth(root.right) + <span class="hljs-number">1</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常用工具类和常用方法"><a href="#常用工具类和常用方法" class="headerlink" title="常用工具类和常用方法"></a>常用工具类和常用方法</h2><h3 id="String-StringBuffer"><a href="#String-StringBuffer" class="headerlink" title="String StringBuffer"></a>String StringBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuffer的：<br>append(String str): 在字符串的末尾追加指定的字符串。<br>insert(<span class="hljs-type">int</span> offset, String str): 在指定的偏移量处插入指定的字符串。<br>replace(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, String str): 使用指定的字符串替换从起始位置到结束位置之间的字符。<br>delete(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end): 删除从起始位置到结束位置之间的字符。<br>length(): 返回字符串的长度。<br>substring(<span class="hljs-type">int</span> start): 返回从指定位置开始到字符串末尾的子字符串。<br>substring(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end): 返回从起始位置到结束位置之间的子字符串。<br>reverse(): 反转字符串。<br>toString(): 将StringBuffer对象转换为普通字符串。<br><br>string<br><span class="hljs-title function_">length</span><span class="hljs-params">()</span>: 返回字符串的长度。<br>charAt(<span class="hljs-type">int</span> index): 返回指定索引位置处的字符。<br>substring(<span class="hljs-type">int</span> beginIndex): 返回从指定索引开始到末尾的子字符串。<br>substring(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex): 返回从起始索引到结束索引之间的子字符串。<br>concat(String str): 将指定的字符串连接到原始字符串的末尾。<br>toUpperCase(): 将字符串转换为大写形式。<br>toLowerCase(): 将字符串转换为小写形式。<br>trim(): 去除字符串两端的空格。<br>startsWith(String prefix): 判断字符串是否以指定的前缀开始。<br>endsWith(String suffix): 判断字符串是否以指定的后缀结束。<br>contains(CharSequence sequence): 判断字符串是否包含指定的字符序列。<br>indexOf(<span class="hljs-type">int</span> ch): 返回指定字符第一次出现的索引。<br>lastIndexOf(<span class="hljs-type">int</span> ch): 返回指定字符最后一次出现的索引。<br>equals(Object obj): 比较字符串是否相等。<br>equalsIgnoreCase(String anotherString): 忽略大小写比较字符串是否相等。<br>replace(<span class="hljs-type">char</span> oldChar, <span class="hljs-type">char</span> newChar): 将字符替换成新字符。<br>replaceAll(String regex, String replacement): 使用正则表达式替换字符串。<br>split(String regex): 使用正则表达式将字符串拆分成字符串数组。<br>join(CharSequence delimiter, CharSequence... elements): 使用指定的分隔符将一组字符串连接成一个字符串。<br>startsWith(String prefix, <span class="hljs-type">int</span> toffset): 判断字符串从指定偏移量开始是否以指定的前缀开始。<br><br>正则表达式<br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$&quot;</span>;<br>        <span class="hljs-keyword">return</span> Pattern.matches(regex, input);<br>        <br>        <span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">replaceSecondOccurrence</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(.*?ijiji.*?)ijiji&quot;</span>;<br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(input);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">occurrenceCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <br>        <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>            occurrenceCount++;<br>            <span class="hljs-keyword">if</span> (occurrenceCount == <span class="hljs-number">2</span>) &#123;<br>                matcher.appendReplacement(sb, <span class="hljs-string">&quot;@&quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        matcher.appendTail(sb);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;This is a test ijiji string ijiji with multiple ijiji occurrences.&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">replacedText</span> <span class="hljs-operator">=</span> replaceSecondOccurrence(text);<br>        System.out.println(<span class="hljs-string">&quot;Replaced Text: &quot;</span> + replacedText);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Arrays-collections-ArrayList"><a href="#Arrays-collections-ArrayList" class="headerlink" title="Arrays collections ArrayList"></a>Arrays collections ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays 类：提供了对数组进行排序、搜索、比较等操作的静态方法。<br>sort(<span class="hljs-type">int</span>[] array)：对 <span class="hljs-type">int</span> 数组进行升序排序。<br>binarySearch(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> key)：在已排序的 <span class="hljs-type">int</span> 数组中使用二分查找算法搜索指定值。<br>equals(<span class="hljs-type">int</span>[] array1, <span class="hljs-type">int</span>[] array2)：比较两个 <span class="hljs-type">int</span> 数组是否相等。<br>toString(<span class="hljs-type">int</span>[] array1)<br>asList(<span class="hljs-type">int</span>[] array)   得到的list不可变<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));  得到可变list<br><br>ArrayList类：<br>转化为数组：<br><span class="hljs-number">1.</span> Integer[] temp1 = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<span class="hljs-comment">//基本没什么软用因为返回值是int[]不吃Integer[];</span><br><span class="hljs-number">2.</span> <span class="hljs-type">int</span>[] temp = list.stream().mapToInt(Integer::intValue).toArray();<br><span class="hljs-number">3.</span> contains()<br><span class="hljs-number">4.</span> add() , get() , set(), remove() , size() , isEmpty().<br><br>Collections类：<br><span class="hljs-number">1.</span> sort(List&lt;T&gt; list)<br><span class="hljs-number">2.</span> binarySearch(List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; list, T key) 不会排序，直接二分法查找<br><span class="hljs-number">3.</span> Collections.reverse(ArrayList);<br><br>System.arraycopy()方法有以下参数：<br>src：源数组，即需要复制元素的数组。<br>srcPos：源数组的起始位置，指定从源数组的哪个索引位置开始复制元素。<br>dest：目标数组<br>destPos：目标数组的起始位置，指定从目标数组的哪个索引位置开始粘贴元素。<br>length：要复制的元素数量，表示从源数组复制的元素个数。<br><br>数组（Array）：可以通过 array.length 来获取数组的长度。<br>字符串（String）：可以使用 .length() 方法来获取字符串的长度，例如 str.length()。<br>列表（List）：可以使用 .size() 方法来获取列表的长度，例如 list.size()。<br>映射（Map）：可以使用 .size() 方法来获取映射中键值对的数量，例如 map.size()。<br>集合（Set）：可以使用 .size() 方法来获取集合中元素的数量，例如 set.size()。<br></code></pre></td></tr></table></figure><h3 id="HashMap-HashSet-Stack-LinkedList"><a href="#HashMap-HashSet-Stack-LinkedList" class="headerlink" title="HashMap HashSet Stack LinkedList"></a>HashMap HashSet Stack LinkedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">////////////////////HashMap/////////////////////</span><br>put(key, value): 将指定的键值对存储到 HashMap 中。<br>get(key): 根据键获取对应的值。<br>remove(key): 根据键从 HashMap 中移除对应的键值对。<br>containsKey(key): 判断 HashMap 中是否包含指定的键。<br>containsValue(value): 判断 HashMap 中是否包含指定的值。<br>size(): 返回 HashMap 中键值对的数量。<br>isEmpty(): 判断 HashMap 是否为空。<br>clear(): 清空 HashMap 中的所有键值对。<br>keySet(): 返回 HashMap 中所有键的集合。<br>values(): 返回 HashMap 中所有值的集合。<br>entrySet(): 返回 HashMap 中所有键值对的集合（Entry 对象）。<br>putAll(map): 将另一个 Map 中的所有键值对存储到当前 HashMap 中。<br><br><span class="hljs-comment">////////////////////////HashSet/////////////////////////</span><br>add(element): 将指定的元素添加到 HashSet 中。<br>remove(element): 从 HashSet 中移除指定的元素。<br>contains(element): 判断 HashSet 是否包含指定的元素。<br>isEmpty(): 判断 HashSet 是否为空。<br>size(): 返回 HashSet 中元素的数量。<br>clear(): 清空 HashSet 中的所有元素。<br>iterator(): 返回一个迭代器，用于遍历 HashSet 中的元素。<br>addAll(collection): 将另一个集合中的所有元素添加到当前 HashSet 中。<br>retainAll(collection): 保留当前 HashSet 中与另一个集合中共有的元素，移除其他元素。<br>removeAll(collection): 移除当前 HashSet 中与另一个集合中相同的所有元素。<br>containsAll(collection): 判断当前 HashSet 是否包含另一个集合中的所有元素。<br>toArray(): 将 HashSet 中的元素转换为数组。<br><br><span class="hljs-comment">//////////////LinkedList/////////////////////</span><br>LinkedList 是 Java 中常用的双向链表实现，它可以用来实现队列和栈的功能。除了队列和栈的方法外，LinkedList 还有其他常用的方法。下面是其中一些常用方法的说明：<br>队列方法（Queue methods）：<br>offer(element): 将指定的元素添加到队尾。<br>poll(): 获取并移除队头元素。<br>peek(): 获取队头元素但不移除。<br>栈方法（Stack methods）：<br>push(element): 将指定的元素推入栈顶。<br>pop(): 弹出栈顶元素。<br>peek(): 获取栈顶元素但不弹出。<br>其他常用方法：<br>add(element): 将指定的元素添加到链表末尾。<br>remove(element): 移除第一个匹配给定元素的节点。 如果linkedlist&lt;Integer&gt;那么是下标位置。<br>get(index): 获取指定位置的元素。<br>set(index, element): 替换指定位置的元素。<br>size(): 返回链表中的元素数量。<br>isEmpty(): 判断链表是否为空。<br>clear(): 清空链表中的所有元素。<br>contains(element): 判断链表是否包含指定的元素。<br>iterator(): 返回一个迭代器，用于遍历链表中的元素。<br><br><span class="hljs-comment">//////////////////////Stack////////////</span><br>push(element): 将元素推入栈顶。<br>pop(): 弹出栈顶元素并将其从栈中移除。<br>peek(): 获取栈顶元素但不将其移除。<br>empty(): 判断栈是否为空。<br>search(element): 查找指定元素在栈中的位置，返回与栈顶的距离（如果不存在，则返回 -<span class="hljs-number">1</span>）。<br></code></pre></td></tr></table></figure><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Java中的Deque（双端队列）实现了Queue和Deque接口，提供了一系列常用的方法来操作队列的两端。以下是Deque常用的方法：<br><br><span class="hljs-number">1.</span> `<span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span>`：将元素插入到Deque的开头。<br><span class="hljs-number">2.</span> `<span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span>`：将元素插入到Deque的末尾。<br><span class="hljs-number">3.</span> `<span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span>`：将元素插入到Deque的开头，如果插入成功则返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span>。<br><span class="hljs-number">4.</span> `<span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span>`：将元素插入到Deque的末尾，如果插入成功则返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span>。<br><span class="hljs-number">5.</span> `E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span>`：移除并返回Deque的第一个元素，如果Deque为空则抛出NoSuchElementException异常。<br><span class="hljs-number">6.</span> `E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span>`：移除并返回Deque的最后一个元素，如果Deque为空则抛出NoSuchElementException异常。<br><span class="hljs-number">7.</span> `E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span>`：移除并返回Deque的第一个元素，如果Deque为空则返回<span class="hljs-literal">null</span>。<br><span class="hljs-number">8.</span> `E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span>`：移除并返回Deque的最后一个元素，如果Deque为空则返回<span class="hljs-literal">null</span>。<br><span class="hljs-number">9.</span> `E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span>`：获取Deque的第一个元素，但不移除该元素，如果Deque为空则抛出NoSuchElementException异常。<br><span class="hljs-number">10.</span> `E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span>`：获取Deque的最后一个元素，但不移除该元素，如果Deque为空则抛出NoSuchElementException异常。<br><span class="hljs-number">11.</span> `E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span>`：获取Deque的第一个元素，但不移除该元素，如果Deque为空则返回<span class="hljs-literal">null</span>。<br><span class="hljs-number">12.</span> `E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span>`：获取Deque的最后一个元素，但不移除该元素，如果Deque为空则返回<span class="hljs-literal">null</span>。<br><span class="hljs-number">13.</span> `<span class="hljs-type">boolean</span> <span class="hljs-title function_">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span>`：从Deque中移除第一次出现的指定元素。<br><span class="hljs-number">14.</span> `<span class="hljs-type">boolean</span> <span class="hljs-title function_">removeLastOccurrence</span><span class="hljs-params">(Object o)</span>`：从Deque中移除最后一次出现的指定元素。<br><span class="hljs-number">15.</span> `<span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>`：判断Deque是否包含指定元素。<br><span class="hljs-number">16.</span> `<span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>`：返回Deque中的元素数量。<br><br>以上是Deque的一些常用方法，可以通过调用这些方法来操作双端队列。<br></code></pre></td></tr></table></figure><h3 id="基础类型相互转化Integer-String-character-double-float-判断是否为数字等。"><a href="#基础类型相互转化Integer-String-character-double-float-判断是否为数字等。" class="headerlink" title="基础类型相互转化Integer,String ,character,double,float.判断是否为数字等。"></a>基础类型相互转化Integer,String ,character,double,float.判断是否为数字等。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer-&gt;String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br>String-&gt;Integer Integer.parseInt(str)<br><br>Integer-&gt;Double num.intValue();<br>Double-&gt;Integer Double.valueOf(d).intValue();<br><br>Character.isDigit(<span class="hljs-type">char</span>)<br>(ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol><li>dp数组，以及下表的含义</li><li>递推公式</li><li>dp数组的初始化</li><li>遍历顺序</li><li>打印dp数组</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通过问题来理解多线程</title>
    <link href="/2023/08/10/%E9%80%9A%E8%BF%87%E9%97%AE%E9%A2%98%E6%9D%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%20(2)/"/>
    <url>/2023/08/10/%E9%80%9A%E8%BF%87%E9%97%AE%E9%A2%98%E6%9D%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%20(2)/</url>
    
    <content type="html"><![CDATA[<h3 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通过一个个问题，逐渐窥探多线程的一个个部分</p><h4 id="线程，线程的理解"><a href="#线程，线程的理解" class="headerlink" title="线程，线程的理解"></a>线程，线程的理解</h4><p>在计算机系统中，各种资源（如内存、CPU时间、文件句柄等）是有限且宝贵的，不同的程序需要共享和竞争这些资源。为了有效地管理这些资源的分配和调度，操作系统引入了进程的概念。</p><p>当一个程序被启动时，操作系统会为其创建一个独立的进程，并给予其一定的资源。每个进程都有自己的内存空间、程序代码、数据和执行状态，以及所需的其他系统资源。这样，不同的程序可以在独立的环境中运行，彼此之间互不干扰。</p><p>通过创建进程，操作系统可以对程序进行管理和控制，包括分配内存空间、分配CPU时间片、调度线程执行、处理输入输出等。操作系统根据调度算法和策略来协调进程之间的执行，以实现多任务并发执行的效果。</p><p>在一个进程内部，可以包含多个线程。每个线程代表了一个独立的执行序列，它具有自己的程序计数器、栈和寄存器等执行上下文。多个线程可以在同一个进程内并发执行，共享该进程的资源。</p><p>当操作系统调度程序将CPU时间片分配给某个进程时，该进程内的多个线程会竞争获取CPU资源。操作系统通过轮转调度算法或其他调度策略，将CPU的执行时间分配给各个线程，以实现多线程的并发执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadT</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">likeLamda</span> <span class="hljs-variable">like3</span> <span class="hljs-operator">=</span> a-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;你好λ&quot;</span> + a);<br>        &#125;;<br><br>        like3.like(<span class="hljs-number">10</span>);<br><br><br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-type">int</span> num;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ; i++)&#123;<br>            System.out.println(num++);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-type">int</span> num ;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ; i++)&#123;<br>            System.out.println(num++);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(ticket &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;----&gt;拿到第&quot;</span> + ticket-- + <span class="hljs-string">&quot;--票&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">likeLamda</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">like</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IlikeLamda</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title class_">likeLamda</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">like</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I like lamda&quot;</span> + a);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="为什么要多线程"><a href="#为什么要多线程" class="headerlink" title="为什么要多线程"></a>为什么要多线程</h4><p>应为在追赶摩尔定律也就是2年翻一倍的运算速度碰壁了。遂出现了多核。但是多核是cpu多核，不是内存多核，而且多核是为了共同 处理一个目标，会出现多核处理一个缓存信息，造成线程安全问题。</p><h4 id="多线程在发生什么的时候，会导致用户态和内核态”两个态之间来回切换"><a href="#多线程在发生什么的时候，会导致用户态和内核态”两个态之间来回切换" class="headerlink" title="多线程在发生什么的时候，会导致用户态和内核态”两个态之间来回切换"></a>多线程在发生什么的时候，会导致用户态和内核态”两个态之间来回切换</h4><p>在多线程编程中，当多个线程同时运行时，它们在用户态和内核态之间来回切换。这种切换是由操作系统内核负责管理的。下面是一些导致用户态和内核态之间切换的常见情况：</p><ol><li>线程阻塞：当一个线程执行一个阻塞操作（例如等待输入&#x2F;输出完成或等待锁释放）时，该线程将进入内核态并被放入睡眠状态。在等待的过程中，其他可运行的线程可以继续执行。当阻塞操作完成后，线程将被唤醒并返回用户态。</li><li>时间片用完：操作系统以时间片为单位分配CPU资源给不同的线程。当一个线程的时间片用完时，操作系统会中断该线程的执行，并将控制权切换到另一个可运行的线程。这个切换过程涉及从用户态切换到内核态，然后再切换回用户态。</li><li>系统调用：当一个线程需要进行一些只能由内核完成的操作时，例如创建新线程、分配内存或打开文件等，它必须通过系统调用来请求操作系统的帮助。在执行系统调用时，线程将从用户态切换到内核态，操作系统会处理相应的请求，并返回结果给用户态。</li></ol><p>总之，多线程在发生线程阻塞、时间片用完或进行系统调用等情况时，会导致用户态和内核态之间的切换。这种切换是为了合理地利用CPU资源，以提供更高效的并发执行能力。</p><h4 id="用户态和内核态的区别"><a href="#用户态和内核态的区别" class="headerlink" title="用户态和内核态的区别"></a>用户态和内核态的区别</h4><p>用户态（User Mode）和内核态（Kernel Mode）是计算机处理器运行时的两种不同的执行模式。</p><ol><li>用户态（User Mode）：<ul><li>在用户态下，应用程序在一个受限的环境中运行，无法直接访问或执行特权指令和硬件资源。</li><li>应用程序只能执行非特权指令，使用分配给它们的有限资源进行操作，如内存、文件和网络等。</li><li>用户态下的应用程序运行速度较快，但对系统的控制力较弱。</li></ul></li><li>内核态（Kernel Mode）：<ul><li>内核态是操作系统的特权执行环境，操作系统内核运行在该模式下，并具有对系统所有资源的完全访问权限。</li><li>内核态可以执行特权指令，如操作硬件设备、修改核心数据结构等。</li><li>内核态下的代码运行速度较慢，但对系统资源和控制权拥有绝对控制力。</li></ul></li></ol><p>切换状态：</p><ul><li>在正常情况下，应用程序运行在用户态，当需要执行特权操作时，如访问硬件设备或执行敏感的操作，应用程序必须通过系统调用方式切换到内核态。这时，CPU会将控制权从用户态切换到内核态，并执行相应的内核代码来完成特权操作。</li><li>内核态执行完后，将结果返回给用户态，并将控制权切换回用户态，应用程序继续执行。</li></ul><h4 id="线程池可以减少用户态和内核态的切换吗？为什么"><a href="#线程池可以减少用户态和内核态的切换吗？为什么" class="headerlink" title="线程池可以减少用户态和内核态的切换吗？为什么"></a>线程池可以减少用户态和内核态的切换吗？为什么</h4><p>是的，线程池可以减少用户态和内核态之间的切换次数。</p><p>在传统的多线程编程模型中，每当需要执行一个任务时，都会创建一个新的线程。这就意味着在任务执行完成后，该线程往往会被销毁，而线程的创建和销毁涉及到用户态和内核态之间的切换。频繁的线程创建和销毁会增加切换的开销，降低系统的性能。</p><p>而使用线程池则可以避免这种频繁的线程创建和销毁。线程池在应用程序启动时创建一定数量的线程，并将它们置于待命状态，等待任务的到来。当有任务需要执行时，线程池中的一个空闲线程会被分配给该任务进行处理，无需额外的线程创建和销毁操作。</p><p>通过线程池，可以实现以下几点减少用户态和内核态切换的优势：</p><ol><li>线程复用：线程池中的线程可以被多个任务重复使用，避免了频繁地创建和销毁线程，减少了切换的开销。</li><li>任务队列：线程池使用任务队列来存储待执行的任务。当一个线程完成当前任务后，可以立即从任务队列中获取下一个任务，从而减少了线程切换的次数。</li><li>线程数量控制：线程池可以根据系统负载情况和资源限制来动态地管理线程数量。通过合理配置线程池的大小，可以控制线程数目在一个适当的范围内，避免过多的线程切换。</li></ol><h4 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h4><p>锁是所有java对象都有的东西，里面纪录了占有这个锁的线程的线程信息。</p><p>java对象的对象头内，存储了java锁的类型，无锁，偏向，轻量，重量锁。</p><h4 id="锁的底层"><a href="#锁的底层" class="headerlink" title="锁的底层"></a>锁的底层</h4><p>锁，说到底还是使用了synchorized实现，synchorized被编译后回变成monitorenter和monitorexit这两个指令来使线程同步。这两个指令通过对类的monitor操作来实现同步。montior也叫锁，管程。每个类都有一个对应的锁。</p><p>synchorized有性能问题，它依赖了操作系统的mutexlook来实现的同步，会涉及到上文切换，内核态用户态转换。非常重量级，有的时候，切换的操作比线程执行还要耗时</p><p>但是从java6开始优化了synchorized，使用了锁进化机制。偏向锁状态下，在对象头内会存放线程id，如果出现线程的竞争，则进化为轻量级锁？？？？？？？？？？？？？</p><h4 id="synchronized底层和monitorenter、monitorexit指令的关系"><a href="#synchronized底层和monitorenter、monitorexit指令的关系" class="headerlink" title="synchronized底层和monitorenter、monitorexit指令的关系"></a>synchronized底层和monitorenter、monitorexit指令的关系</h4><p>在Java中，关键字<code>synchronized</code>用于实现线程之间的同步，确保多个线程对共享资源的安全访问。底层实现中，<code>synchronized</code>关键字与<code>monitorenter</code>和<code>monitorexit</code>指令密切相关。</p><p><code>monitorenter</code>和<code>monitorexit</code>是Java虚拟机（JVM）提供的同步指令，用于对监视器（Monitor）的获取和释放。</p><p>当Java代码中使用<code>synchronized</code>关键字修饰一个方法或代码块时，编译器会在生成的字节码中插入<code>monitorenter</code>和<code>monitorexit</code>指令。这两个指令将会在进入和离开<code>synchronized</code>代码块时被执行。</p><p>具体地，<code>monitorenter</code>指令用于获取对象的监视器（锁），它会尝试获得锁并标记当前线程作为锁的持有者。如果锁已经被其他线程持有，则当前线程将会阻塞等待直到锁可用。</p><p><code>monitorexit</code>指令用于释放对象的监视器（锁），将锁的持有者标记清除，并尝试唤醒等待该锁的其他线程。</p><p>通过<code>monitorenter</code>和<code>monitorexit</code>指令的配合，JVM实现了<code>synchronized</code>关键字的语义，确保对被<code>synchronized</code>修饰的代码块或方法的互斥访问。</p><p>需要注意的是，<code>synchronized</code>关键字不仅用于同步代码块和方法，还可以用于修饰非静态方法和静态方法、实例对象和类对象等。在不同的场景下，编译器会生成不同的字节码指令来支持<code>synchronized</code>的语义，但核心思想是使用<code>monitorenter</code>和<code>monitorexit</code>指令进行监视器的获取和释放。</p><h4 id="上面的描述中，监视器是每个java对象都拥有的对吗？"><a href="#上面的描述中，监视器是每个java对象都拥有的对吗？" class="headerlink" title="上面的描述中，监视器是每个java对象都拥有的对吗？"></a>上面的描述中，监视器是每个java对象都拥有的对吗？</h4><p>是的，每个Java对象都拥有一个与之相关联的监视器（Monitor），也可以称为锁。监视器是实现Java中<code>synchronized</code>关键字的机制之一。</p><p>每个Java对象都有一个与之关联的监视器，该监视器的获取和释放用于控制对对象的同步访问。当某个线程进入<code>synchronized</code>代码块或方法时，它会尝试获取该对象的监视器（锁）。如果没有其他线程持有该锁，那么该线程会成功获取锁并继续执行；如果锁已被其他线程持有，那么该线程将被阻塞，直到获取到锁为止。</p><p>监视器不是每个Java对象本身所独有的，而是与对象关联的一种同步机制。它的用途是保证对共享资源的安全访问和操作。当一个线程获得某个对象的监视器后，其他线程无法同时获得该对象的监视器，从而实现了对该对象的互斥访问。</p><p>需要注意的是，每个Java对象只有一个与之关联的监视器。如果在代码中使用<code>synchronized</code>关键字修饰不同的对象，则它们会拥有各自独立的监视器，互相之间不会产生影响。</p><p>总结来说，每个Java对象都拥有一个与之关联的监视器（锁），用于实现对该对象的同步访问和操作，确保多线程之间的互斥性。</p><h4 id="java多线程中monitor就是锁，若一个线程占用锁，是否意味着该锁内存储着锁被那个线程占用的信息"><a href="#java多线程中monitor就是锁，若一个线程占用锁，是否意味着该锁内存储着锁被那个线程占用的信息" class="headerlink" title="java多线程中monitor就是锁，若一个线程占用锁，是否意味着该锁内存储着锁被那个线程占用的信息"></a>java多线程中monitor就是锁，若一个线程占用锁，是否意味着该锁内存储着锁被那个线程占用的信息</h4><p>是的，当一个线程占用了锁时，该锁内部会存储着关于锁被哪个线程占用的信息。这个信息包括了持有锁的线程的标识，并且可以通过监视器来进行获取。</p><p>在Java中，每个对象都有一个与之关联的监视器（锁）。当一个线程成功获取了一个对象的监视器（即获取到了该对象的锁），该线程会成为锁的持有者。持有锁的线程的标识会被存储在锁的内部，以便其他线程可以查询该信息。</p><p>其他线程在尝试获取同一个对象的监视器（即尝试获取该对象的锁）时，会先检查锁的状态。如果锁已经被其他线程占用，则等待锁释放；如果锁未被占用，则尝试获取锁并将自己标记为锁的持有者。</p><p>锁的内部存储了关于锁被哪个线程占用的信息，这种机制使得Java多线程能够实现同步和互斥访问。这样做的好处是，它允许每个线程在获取到锁之前等待，从而实现线程之间的协调和资源的正确共享。</p><p>需要注意的是，当一个线程释放了锁，也就是锁的持有者变为空闲时，锁的内存中的持有者信息会被清除，以便其他线程能够获取该锁。</p><h4 id="对像头内有什么？"><a href="#对像头内有什么？" class="headerlink" title="对像头内有什么？"></a>对像头内有什么？</h4><ol><li>标记字（Mark Word）：用于表示对象的状态和标记信息。它可以包含锁的信息、哈希码、GC相关的标记等。</li><li>类型指针（Class Pointer）：指向对象所属的类的元数据，用于确定对象的类型和访问类的方法。</li><li>数组长度（Array Length）：对于数组对象，会包含数组的长度信息。</li><li>对齐补充（Alignment Padding）：内存对齐的需要，填充字节来保证对象的起始地址符合对齐要求。</li></ol><p>这些信息通常存储在对象的头部，而对象的实际数据则存储在对象的实例变量区域。具体的对象布局和内存分配方式在不同的JVM实现中可能存在差异，但以上提到的是一些常见的信息。</p><h4 id="相较于线程被挂起，线程自旋有什么优缺点"><a href="#相较于线程被挂起，线程自旋有什么优缺点" class="headerlink" title="相较于线程被挂起，线程自旋有什么优缺点"></a>相较于线程被挂起，线程自旋有什么优缺点</h4><p>线程自旋和线程挂起是两种不同的并发控制机制，它们各有优缺点。</p><p>线程自旋是指当一个线程在访问共享资源时，如果发现该资源正在被其他线程占用，它会持续地循环检查该资源是否可用，而不是立刻被挂起。线程自旋的优点包括：</p><ol><li>响应速度高：线程自旋无需进行上下文切换和线程挂起的操作，减少了线程切换带来的开销，因此响应速度更快。</li><li>避免线程切换：线程自旋避免了线程从用户态到内核态的切换过程，减少了系统调用的开销，尤其是在短时间内需要频繁访问资源的场景下。</li></ol><p>然而，线程自旋也存在一些缺点：</p><ol><li>占用CPU资源：线程自旋会占用CPU资源，如果自旋时间过长或没有其他线程释放资源，会导致CPU资源浪费，降低系统的整体性能。</li><li>长时间自旋造成延迟：如果某个线程一直在自旋，而其他线程一直占用着该资源，会导致自旋线程长时间得不到执行，造成延迟。</li></ol><p>相比之下，线程挂起是指当一个线程发现某个资源被占用时，它会被操作系统挂起（即阻塞），直到资源可用再恢复执行。线程挂起的优点包括：</p><ol><li>节省CPU资源：线程挂起不会占用CPU资源，可以避免自旋时的长时间空转浪费CPU。</li><li>释放CPU给其他线程：线程挂起释放了CPU资源，让其他线程有机会执行，提高了系统的并发能力。</li></ol><p>然而，线程挂起也存在一些缺点：</p><ol><li><p>上下文切换开销：线程挂起需要进行上下文切换，从用户态切换到内核态，涉及到保存和恢复上下文的开销。</p></li><li><p>较慢的恢复时间：当线程挂起后，等待资源可用时需要重新唤醒线程，这个过程通常比较耗时。</p></li></ol><h4 id="线程挂起了，线程就进入阻塞状态了对吗"><a href="#线程挂起了，线程就进入阻塞状态了对吗" class="headerlink" title="线程挂起了，线程就进入阻塞状态了对吗"></a>线程挂起了，线程就进入阻塞状态了对吗</h4><p>对</p><h4 id="yeild方法或者join方法，会让线程阻塞吗？"><a href="#yeild方法或者join方法，会让线程阻塞吗？" class="headerlink" title="yeild方法或者join方法，会让线程阻塞吗？"></a>yeild方法或者join方法，会让线程阻塞吗？</h4><p><code>yield()</code>方法和<code>join()</code>方法都可以导致线程阻塞，但具体的阻塞行为和作用不完全一样。</p><ul><li><code>yield()</code>方法：<code>yield()</code>方法是一个静态方法，用于提示调度器当前线程愿意放弃CPU资源，将执行的机会让给其他线程。调用<code>yield()</code>方法会使当前线程从运行状态转变为就绪状态，然后由调度器再次决定是否将CPU资源分配给该线程。虽然线程在调用<code>yield()</code>后会放弃CPU的执行权，但并不表示一定会被阻塞，因为线程可能很快就再次获取到CPU时间片继续执行。</li><li><code>join()</code>方法：<code>join()</code>方法是一个实例方法，用于在当前线程中等待另一个线程的完成。调用<code>join()</code>方法会使当前线程进入阻塞状态，直到目标线程执行完毕才恢复执行。在主线程中调用某个子线程的<code>join()</code>方法，主线程会被阻塞直到子线程执行完毕或等待超时。这个方法常用于多个线程间的协同操作。</li></ul><p>总结起来，<code>yield()</code>方法是主动放弃CPU资源的方式，当前线程会进入就绪状态而不是阻塞状态，不会被长时间阻塞。而<code>join()</code>方法是通过等待目标线程执行完毕来实现阻塞，在等待期间当前线程将被阻塞，直到目标线程完成。</p><h4 id="yield会放弃资源吗？，join呢？"><a href="#yield会放弃资源吗？，join呢？" class="headerlink" title="yield会放弃资源吗？，join呢？"></a>yield会放弃资源吗？，join呢？</h4><p>对于<code>yield()</code>方法和<code>join()</code>方法，它们的作用是不同的，不涉及资源的放弃。</p><ul><li><code>yield()</code>方法：<code>yield()</code>方法是一个静态方法，调用它会提示调度器当前线程愿意放弃CPU资源，将执行的机会让给其他具备相同或更高优先级的线程。当线程调用<code>yield()</code>方法后，只是暂时放弃当前的执行权，让其他线程有机会执行，但并不会主动放弃任何资源。</li><li><code>join()</code>方法：<code>join()</code>方法是一个实例方法，用于在当前线程中等待另一个线程的完成。调用<code>join()</code>方法会使当前线程进入阻塞状态，并等待目标线程执行完毕。调用线程调用<code>join()</code>方法后，将等待目标线程终止，期间不会占用太多资源。线程之间通过<code>join()</code>方法的协作是通过等待和通知机制实现的，而不是通过主动放弃资源。</li></ul><p>所以，<code>yield()</code>方法和<code>join()</code>方法并不会主动放弃或释放资源，它们更关注于线程的调度和协作。<code>yield()</code>方法只是暂时放弃当前的执行权，给其他线程一些机会，而<code>join()</code>方法是等待目标线程执行完毕。线程对于资源的获取和释放，在其他地方进行处理，例如锁的获取和释放、资源的关闭等。</p><h4 id="假设A线程在运行，B线程自旋，等待A释放一个锁，那么，为什么B可以自旋？它明明没获得cpu的执行"><a href="#假设A线程在运行，B线程自旋，等待A释放一个锁，那么，为什么B可以自旋？它明明没获得cpu的执行" class="headerlink" title="假设A线程在运行，B线程自旋，等待A释放一个锁，那么，为什么B可以自旋？它明明没获得cpu的执行"></a>假设A线程在运行，B线程自旋，等待A释放一个锁，那么，为什么B可以自旋？它明明没获得cpu的执行</h4><p>（其实获得了，因为线程B是线程B，A是A，都在运行）</p><h4 id="cas是什么？"><a href="#cas是什么？" class="headerlink" title="cas是什么？"></a>cas是什么？</h4><p>CAS（Compare and Swap）是一种并发算法，用于实现多线程环境下的原子操作。它是乐观锁的一种常见实现方式。</p><p>CAS操作包含三个参数：内存地址（或者称为变量的指针）、期望值和更新值。它的原理是先比较内存地址上的值是否与期望值相等，如果相等，则将内存地址上的值更新为新的值；如果不相等，则表示其他线程并发修改了该值，更新失败。</p><p>CAS操作通常使用原子指令来确保操作的原子性，例如CPU提供的CMPXCHG指令。这些指令能够在一个原子步骤中执行比较和更新操作，避免了并发条件下的竞态条件。</p><p>CAS的优点在于它不需要加锁，因此可以避免悲观锁带来的线程阻塞和上下文切换开销，同时能够保证共享资源的原子性。然而，由于CAS操作需要进行多次尝试，当并发冲突频繁发生时，可能会导致自旋的开销增加，并且并发冲突较多时会导致性能下降。</p><p>CAS在并发编程中广泛应用于无锁数据结构、原子变量、线程安全算法等方面，如AtomicInteger、AtomicLong等原子类就是基于CAS实现的。它为并发编程提供了一种高效且线程安全的方式来处理共享资源的访问和更新。</p><h4 id="cas的aba问题和解决方案"><a href="#cas的aba问题和解决方案" class="headerlink" title="cas的aba问题和解决方案"></a>cas的aba问题和解决方案</h4><p>CAS的ABA问题是指在多线程环境中，在执行CAS操作时，由于共享数据发生了两次变化（从A到B再回到A），导致比较操作仍然返回成功，但实际上共享数据已经发生了变化。</p><p>ABA问题可能会对一些需要关注数据历史变化的情况产生影响，例如使用CAS来实现无锁数据结构、并发栈等。</p><p>下面是一些常见的解决方案：</p><ol><li>增加版本号或者时间戳：在执行CAS时，除了比较值之外，还可以增加一个版本号或者时间戳，每次更新时都会使版本号增加。这样，即使共享数据的值经过多次变化，通过版本号或时间戳的比较，可以区分出是否发生了ABA问题。</li><li>使用带有标记的数据结构：可以使用带有标记的数据结构，例如带有ABA标记的节点。当进行CAS操作时，除了比较值之外，还需要检查标记是否匹配。如果标记不匹配，则表示发生了ABA问题。</li><li>引入引用计数：为变量引入引用计数的概念，每次修改变量时，引用计数加1。这样，在进行CAS操作时，除了比较值之外，还要比较引用计数。如果引用计数不匹配，则表示发生了ABA问题。</li><li>使用双重CAS操作：可以使用两次CAS操作，第一次CAS比较值的同时获取当前的版本号或时间戳，第二次CAS比较值的同时比较之前获取到的版本号或时间戳。这样，即使共享数据的值经过多次变化，通过两次CAS操作的结果，可以避免ABA问题。</li></ol><p>需要根据具体情况选择适合的解决方案，以确保在CAS操作中能够正确处理ABA问题。</p><h4 id="当我使用原子类的int进行cas操作，然后自旋次数超过默认会发生什么？"><a href="#当我使用原子类的int进行cas操作，然后自旋次数超过默认会发生什么？" class="headerlink" title="当我使用原子类的int进行cas操作，然后自旋次数超过默认会发生什么？"></a>当我使用原子类的int进行cas操作，然后自旋次数超过默认会发生什么？</h4><p>当使用原子类的<code>int</code>类型进行CAS（Compare and Swap）操作，并且自旋次数超过默认值时，将会发生以下情况：</p><ol><li><p>自旋等待：如果自旋次数还未达到默认值，线程将会继续自旋等待，尝试执行CAS操作直到成功。</p></li><li><p>自旋次数超过默认值：当自旋次数超过默认值，可能会发生两种情况：</p><p>a. 当前线程会继续自旋等待，直到其他线程释放锁或资源并使得CAS操作成功，或者直到线程调度器主动切换到其他线程执行。</p><p>b. 在某些编程语言或框架中，针对自旋次数超过默认值的情况，可能会触发特定策略来避免资源的过度消耗或线程的饥饿情况。比如，可以选择将当前线程转为阻塞状态，并进入等待队列，让其他线程有机会执行。等待队列中的线程会在资源释放后按照一定的调度策略被唤醒，并再次尝试执行CAS操作。</p></li></ol><p>总之，自旋次数超过默认值后的具体行为取决于编程语言、框架或操作系统的实现。一般而言，会继续等待或通过其他机制来避免资源的浪费和线程的长时间占用。建议在实际应用中根据具体场景和性能需求合理设置自旋次数，以平衡并发性能和系统资源消耗。</p><h4 id="如果线程池内线程被挂起了，那么它之后会被如何？"><a href="#如果线程池内线程被挂起了，那么它之后会被如何？" class="headerlink" title="如果线程池内线程被挂起了，那么它之后会被如何？"></a>如果线程池内线程被挂起了，那么它之后会被如何？</h4><h4 id="AQs"><a href="#AQs" class="headerlink" title="AQs"></a>AQs</h4><p>太难了，能说多少说多少了属于是</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工作经验</title>
    <link href="/2023/08/10/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%20(2)/"/>
    <url>/2023/08/10/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%20(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="上班总结"><a href="#上班总结" class="headerlink" title="上班总结"></a>上班总结</h2><p>今天上班，效率非常低，简单的对接，做的很丑陋。</p><p>问题</p><ol><li>对接步骤是 双方确定版本号-》我发件-》他收件反馈-》我收到反馈-》结束。那么在版本号未确定的情况下后续都无意义。在组长告诉我说版本号已经对好后，我一口气发了好多件，然后全都失败。后来排查才发现是版本号没对</li><li>版本号没对后我自己开始对版本号，但是没跟组长说，没想到他也在干相同的活，所以在干不是自己被交代的活or不确定是否是自己干的时候，要先问清楚</li><li>版本号对好后，我发件，甲方问我，除了a，还要b事件嘛？我不确定，说不用，就a即可，然后成功搞砸，做重复的事情。</li><li>在遇到bug，我自己重试了一遍，未能解决，遂找组长。记得记录下来（遇到法人找不到，清楚cooky）</li><li>在自己写版本号的时候，有一个写了一半忘记写了，然后跟组长说写了，导致无用功。</li><li>写到快下班的时候，才发现，我负责的部分业态都有问题，所以等通知。</li></ol><h3 id="有关积累"><a href="#有关积累" class="headerlink" title="有关积累"></a>有关积累</h3><ol><li>积累真的很重要，所有转瞬即逝的思考和念头一定要抓住，然后思考。</li><li>这些不思考，不记录，不积累，就会导致幼稚和过慢的成长。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编写sql的思考</title>
    <link href="/2023/08/10/%E7%BC%96%E5%86%99sql%E7%9A%84%E6%80%9D%E8%80%83%20(2)/"/>
    <url>/2023/08/10/%E7%BC%96%E5%86%99sql%E7%9A%84%E6%80%9D%E8%80%83%20(2)/</url>
    
    <content type="html"><![CDATA[<p>练习sql过程中的感悟                                                                                                                                                                  </p><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h3 id="复杂联合查询"><a href="#复杂联合查询" class="headerlink" title="复杂联合查询"></a>复杂联合查询</h3><p>编写SQL查询以查找每个部门中薪资最高的员工。 </p><p>每个。。。最。。的。。</p><p>思路：</p><ol><li><p>group by子查询每个最。。的</p></li><li><p>连接 in &#x2F; not in</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br> d.name Department,<br> e.name Employee ,<br> e.salary Salary <br>from Employee e left join Department d on e.departmentId = d.id <br>where <br>(e.departmentId , e.salary) in <br>( select departmentId,max(salary) from Employee group by departmentId)<br><br></code></pre></td></tr></table></figure><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>编写 SQL 查询对分数进行排序。排名按以下规则计算:</p><ol><li>分数应按从高到低排列。</li><li>如果两个分数相等，那么两个分数的排名应该相同。</li><li>在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select a.score as Score,<br>(select count(distinct b.score) from scores as b<br>where  b.Score &gt;= a.Score) as &#x27;rank&#x27;<br>from scores as a <br>order by a.score desc<br></code></pre></td></tr></table></figure><h3 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h3><p>编写一个 SQL 查询，获取并返回 <code>Employee</code> 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 <code>null</code> 。</p><p>limit  index，num从第1个开始，选择一个</p><p>limit i 返回前i个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>(select DISTINCT salary from employee <br>order by salary desc<br>limit 0 , 1)<br>as  SecondHighestSalary<br></code></pre></td></tr></table></figure><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p>写一条 SQL 语句，查询患有 I 类糖尿病的患者 ID （patient_id）、患者姓名（patient_name）以及其患有的所有疾病代码（conditions）。I 类糖尿病的代码总是包含前缀 DIAB1 。</p><ol><li>%匹配的是字符串，任意长度，不包括空格</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from Patients p<br>where(<br>    p.conditions like &#x27;DIAB1%&#x27; or conditions like &#x27;% DIAB1%&#x27;<br>)<br></code></pre></td></tr></table></figure><h3 id="销售分析"><a href="#销售分析" class="headerlink" title="销售分析"></a>销售分析</h3><p>编写一个SQL查询，报告<code>2019年春季</code>才售出的产品。即<strong>仅</strong>在<code>**2019-01-01**</code>至<code>**2019-03-31**</code>（含）之间出售的商品。</p><ol><li>between and</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">输入：<br>Product table:<br>+------------+--------------+------------+<br>| product_id | product_name | unit_price |<br>+------------+--------------+------------+<br>| 1          | S8           | 1000       |<br>| 2          | G4           | 800        |<br>| 3          | iPhone       | 1400       |<br>+------------+--------------+------------+<br>Sales table:<br>+-----------+------------+----------+------------+----------+-------+<br>| seller_id | product_id | buyer_id | sale_date  | quantity | price |<br>+-----------+------------+----------+------------+----------+-------+<br>| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |<br>| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |<br>| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |<br>| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |<br>+-----------+------------+----------+------------+----------+-------+<br>输出：<br>+-------------+--------------+<br>| product_id  | product_name |<br>+-------------+--------------+<br>| 1           | S8           |<br>+-------------+--------------+<br>select distinct  p.product_id  ,p.product_name from Product p , Sales s1<br>where p.product_id = s1.product_id and p.product_id not in(<br>    select product_id from Sales s<br>    where(<br>        s.sale_date not between &#x27;2019-01-01&#x27; and &#x27;2019-03-31&#x27; <br>        # s.sale_date is null<br>    )<br>)<br><br></code></pre></td></tr></table></figure><h3 id="判断空的方法"><a href="#判断空的方法" class="headerlink" title="判断空的方法"></a>判断空的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select DISTINCT IFNULL(b.ssfk, 0) <br>from cxc b,sysgani c <br>where b.gldw=c.orgid and ssfk is null / is not null<br></code></pre></td></tr></table></figure><h3 id="更新和修改的复杂语句"><a href="#更新和修改的复杂语句" class="headerlink" title="更新和修改的复杂语句"></a>更新和修改的复杂语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#更新的复杂语句<br>UPDATE student SET ssex=&#x27;M&#x27;<br> WHERE sname not in (select sname from student s);<br><br>#删除的复杂语句<br>DELETE FROM student WHERE sname in (select sname from  student left join sc on student.sid = sc.sid where( student.sid = sc.sid ));<br><br></code></pre></td></tr></table></figure><h3 id="注意权限关系分数排名"><a href="#注意权限关系分数排名" class="headerlink" title="注意权限关系分数排名"></a>注意权限关系分数排名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select a.score ,<br>    (select distinct count(distinct b.score) <br>        from scores b<br>        where  b.Score &gt;= a.Score) as &#x27;rank&#x27;<br>from scores a <br>order by a.score desc<br><br></code></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#示例；在表GoodsMade_Labour的SID列上创建唯一索引IX_GoodsMade_Labour，代码如下：<br>create unique index IX_GoodsMade_Labour on GoodsMade_Labour(SID)<br><br>#如果要创建聚集索引，可使用关键字clustered,代码如下：<br>create unique clustered index IX_GoodsMade_Labour on GoodsMade_Labour(SID)<br><br>#1.添加PRIMARY KEY（主键索引）<br>mysql&gt;ALTER TABLE table_name ADD PRIMARY KEY ( column )<br><br>#2.添加UNIQUE(唯一索引)<br>mysql&gt;ALTER TABLE table_name ADD UNIQUE (<br>column<br>)<br><br>#3.添加INDEX(普通索引)<br>mysql&gt;ALTER TABLE table_name ADD INDEX index_name ( column )<br><br>#4.添加FULLTEXT(全文索引)<br>mysql&gt;ALTER TABLE table_name ADD FULLTEXT ( column)<br><br>#5.添加多列索引<br>mysql&gt;ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 )<br></code></pre></td></tr></table></figure><h3 id="对列的操作"><a href="#对列的操作" class="headerlink" title="对列的操作"></a>对列的操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改表名：alter table t_book rename to bbb;<br><br>添加列：alter table 表名 add column 列名 varchar(30);<br><br>删除列：alter table 表名 drop column 列名;<br><br>修改列名MySQL： alter table bbb change nnnnn hh int;<br><br>修改列属性：alter table t_book modify name varchar(22);  <br><br></code></pre></td></tr></table></figure><h3 id="一些sql"><a href="#一些sql" class="headerlink" title="一些sql"></a>一些sql</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br><br>create database hello;<br>use hello;<br><br>create table student(<br>                        sid int(11),<br>                        sname varchar(10),<br>                        birthday datetime,<br>                        ssex varchar(10),<br>                        classid int(11)<br>);<br>create table sc(<br>                   sid int(11),<br>                   cid int(11),<br>                   score int(11)<br>);<br>create table course(<br>                       cid int(11),<br>                       cname varchar(10),<br>                       tid varchar(10)<br>);<br>create table class(<br>                      classid int(11),<br>                      classname varchar(20)<br>);<br>create table teacher(<br>                        tid int(11)primary key,<br>                        tname varchar(10),<br>                        tsex tinyint(4),<br>                        tbirthday date,<br>                        taddress varchar(255),<br>                        temail varchar(255),<br>                        tmoney decimal(20,2)<br>);<br><br>select * from student,class where student.classid = class.classid;<br><br>insert into class(classid,classname) values (1,&#x27;class1&#x27;),(2,&#x27;class2&#x27;),(3,&#x27;class3&#x27;),(4,&#x27;class4&#x27;),(5,&#x27;class5&#x27;);<br><br>insert into student(sid,sname,birthday,ssex,classid) values (1,&#x27;littleRed&#x27;,null,&#x27;girl&#x27;,1),(2,&#x27;littleMin&#x27;,null,&#x27;girl&#x27;,1),(6,&#x27;littleZhan&#x27;,null,&#x27;girl&#x27;,1),(3,&#x27;littleBlue&#x27;,null,&#x27;girl&#x27;,2),(4,&#x27;little1&#x27;,null,&#x27;girl&#x27;,3),(5,&#x27;little2&#x27;,null,&#x27;girl&#x27;,4);<br><br>insert into sc(sid,cid,score) values (1,1,90),(1,2,80),(2,1,40),(2,2,70);<br>insert into sc value (3,1,90);<br><br>insert into course(cid,cname,tid) values (1,&#x27;math&#x27;,1),(2,&#x27;english&#x27;,2);<br><br>select count(*) from student,class,sc;<br><br>select * from student,class where student.classid = class.classid;<br><br>#同时将两表作为参考对象，根据ON后给出的两表的条件将两表连接起来。结果则是两表同时满足ON后的条件的部分才会列出。<br>select * from student<br>                  inner join sc on student.sid=sc.sid;<br><br>#是以左表为基础，根据ON后给出的两表的条件将两表连接起来。结果会将左表所有的查询信息列出，而右表只列出ON后条件与左表满足的部分。<br>select * from student<br>                  left join class<br>                            on student.classid=class.classid;<br><br>select * from class<br>    right join  student on class.classid = student.classid;<br><br>#查找语文相同的学生个数<br>select score,count(*) from sc<br>where cid = &#x27;1&#x27;<br>group by score<br>having count(*) &gt;= 2;<br><br>#查询出每门课都大于80分的学生的姓名 有bug<br>select sid from student<br>where sid not in<br>      (select  sid  from sc where score &lt; 80);<br><br>#查询各科成绩平均分，显示课程名称和平均分并按照平均分降序排序<br>select cname, avg(score) 平均分 from course,sc<br>where course.cid = sc.cid<br>group by course.cid<br>order by 平均分 desc;<br><br>#查询考试超过2门不及格学生的平均成绩<br>select avg(score) from sc where sid in<br>                                (select sid from sc where score &lt; 60 group by sid having count(*) &gt;=2);<br><br>#in ，not in的用法<br>SELECT * FROM TABLE1 a WHERE a.id NOT IN (SELECT b.id FROM TABLE2 b);<br><br>#use group by needs attention<br>SELECT max(classid) from  class group by<br>                          classname;<br><br>#删除某列的语法<br>alter table course delete colunm tid;<br><br>#更新的复杂语句<br>UPDATE student SET ssex=&#x27;M&#x27;<br> WHERE sname not in (select sname from student s);<br><br>#删除的复杂语句<br>DELETE FROM student WHERE sname in (select sname from  student left join sc on student.sid = sc.sid where( student.sid = sc.sid ));<br><br><br><br></code></pre></td></tr></table></figure><h3 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h3><h4 id="字符长度"><a href="#字符长度" class="headerlink" title="字符长度"></a>字符长度</h4><p><img src="C:\Users\FLZ\AppData\Roaming\Typora\typora-user-images\image-20230514144351486.png" alt="image-20230514144351486"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> tweet_id <span class="hljs-keyword">from</span> tweets<br><br><span class="hljs-keyword">where</span> length(content) <span class="hljs-operator">&gt;</span> <span class="hljs-number">15</span> <br></code></pre></td></tr></table></figure><h4 id="group-by-count-计算行数-判断空"><a href="#group-by-count-计算行数-判断空" class="headerlink" title="group by+count(*)计算行数,判断空"></a>group by+count(*)计算行数,判断空</h4><p>conut（*）在内容为空的时候也会加，反正就是算行数</p><p><img src="D:\Study\求职\学习笔记\图片文件\EE69.png" alt="EE69"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> v.customer_id ,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) count_no_trans  <span class="hljs-keyword">from</span> visits v<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>    transactions t<br><span class="hljs-keyword">on</span> <br>    v.visit_id <span class="hljs-operator">=</span> t.visit_id<br><span class="hljs-keyword">where</span> <br>    t.amount <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>    v.customer_id<br><br></code></pre></td></tr></table></figure><h4 id="笛卡尔积，利用空计数不增加"><a href="#笛卡尔积，利用空计数不增加" class="headerlink" title="笛卡尔积，利用空计数不增加"></a>笛卡尔积，利用空计数不增加</h4><p><img src="D:\Study\求职\学习笔记\图片文件\UPO.png" alt="UPO"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> stu.student_id , stu.student_name, sub.subject_name, <span class="hljs-built_in">count</span>(e.student_id) attended_exams<br><span class="hljs-keyword">from</span> <br>    students stu <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> subjects sub<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span><br>    examinations e<br><span class="hljs-keyword">on</span> <br>    e.student_id <span class="hljs-operator">=</span> stu.student_id <span class="hljs-keyword">and</span> e.subject_name <span class="hljs-operator">=</span> sub.subject_name<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> stu.student_id , stu.student_name, sub.subject_name<br><span class="hljs-keyword">Order</span> <span class="hljs-keyword">by</span> student_id,subject_name<br></code></pre></td></tr></table></figure><h4 id="group-by-having"><a href="#group-by-having" class="headerlink" title="group by+having"></a>group by+having</h4><p><img src="D:\Study\求职\学习笔记\图片文件\0S2VT.png" alt="0S2VT"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> e1.name <br><span class="hljs-keyword">from</span> <br>    employee e1<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>    employee e2<br><span class="hljs-keyword">on</span><br>    e1.id <span class="hljs-operator">=</span> e2.managerId<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>    e1.id<br><span class="hljs-keyword">having</span> <br>    <span class="hljs-built_in">count</span>(e2.name) <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><p>子查询</p><p><img src="D:\Study\求职\学习笔记\图片文件\EQL3.png" alt="EQL3"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>    contest_id ,round( (<span class="hljs-built_in">count</span>(contest_id) <span class="hljs-operator">/</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> users))<span class="hljs-operator">*</span><span class="hljs-number">100</span>  , <span class="hljs-number">2</span>) percentage <br><span class="hljs-keyword">from</span> <br>    register r<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>    contest_id<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>    percentage <span class="hljs-keyword">desc</span> , contest_id<br></code></pre></td></tr></table></figure><h4 id="问题，left-join"><a href="#问题，left-join" class="headerlink" title="问题，left join"></a>问题，left join</h4><p>a left join b</p><p>on ..</p><p>则a，后边加了b几行的数据，然后把几行b都加起来可以吗</p><h4 id="日期-group-by"><a href="#日期-group-by" class="headerlink" title="日期 , group by"></a>日期 , group by</h4><p><img src="D:\Study\求职\学习笔记\图片文件\LRP65RO0.png" alt="LRP65RO0"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>    DATE_FORMAT(trans_date, <span class="hljs-string">&#x27;%Y-%m&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">month</span>,<br>    country ,<br>    <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)trans_count ,<br>    <span class="hljs-built_in">sum</span>(if(state<span class="hljs-operator">=</span><span class="hljs-string">&#x27;approved&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))approved_count ,<br>    <span class="hljs-built_in">sum</span>(amount)trans_total_amount , <br>    <span class="hljs-built_in">sum</span>(if(state<span class="hljs-operator">=</span><span class="hljs-string">&#x27;approved&#x27;</span>,amount,<span class="hljs-number">0</span>))approved_total_amount<br><span class="hljs-keyword">from</span> <br>    Transactions<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>    <span class="hljs-keyword">month</span>,country<br></code></pre></td></tr></table></figure><h4 id="分组-最-group-by"><a href="#分组-最-group-by" class="headerlink" title="分组+最+group by"></a>分组+最+group by</h4><p><img src="D:\Study\求职\学习笔记\图片文件\53LK.png" alt="53LK"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    round(<span class="hljs-built_in">sum</span>(if(order_date <span class="hljs-operator">=</span> customer_pref_delivery_date ,<span class="hljs-number">1</span> ,<span class="hljs-number">0</span>)) <span class="hljs-operator">*</span> <span class="hljs-number">100</span> <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),<span class="hljs-number">2</span>)<br>    immediate_percentage <br><span class="hljs-keyword">from</span> <br>    delivery d1<br><span class="hljs-keyword">where</span><br>    (customer_id,order_date) <span class="hljs-keyword">in</span><br>    (<span class="hljs-keyword">select</span> <br>        customer_id,<span class="hljs-built_in">min</span>(order_date) <br>    <span class="hljs-keyword">from</span><br>        delivery d2<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>        customer_id<br>    )<br></code></pre></td></tr></table></figure><h4 id="if-判断空"><a href="#if-判断空" class="headerlink" title="if 判断空"></a>if 判断空</h4><p>if(a.id is not null,1,0)</p><h4 id="判断不同种-distinct"><a href="#判断不同种-distinct" class="headerlink" title="判断不同种 + distinct"></a>判断不同种 + distinct</h4><p><img src="D:\Study\求职\学习笔记\图片文件\C0N.png" alt="C0N"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>    teacher_id , <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> subject_id) cnt <br><span class="hljs-keyword">from</span> <br>    teacher <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>    <br>    teacher_id<br></code></pre></td></tr></table></figure><h4 id="查询-老师a-有所有课程b-group-having-结果集内有空的解决方法"><a href="#查询-老师a-有所有课程b-group-having-结果集内有空的解决方法" class="headerlink" title="查询 老师a 有所有课程b  group + having   结果集内有空的解决方法"></a>查询 老师a 有所有课程b  group + having   结果集内有空的解决方法</h4><p><img src="D:\Study\求职\学习笔记\图片文件\J307XNE.png" alt="J307XNE"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>    <span class="hljs-keyword">distinct</span> customer_id<br><span class="hljs-keyword">from</span> <br>    customer c<br><span class="hljs-keyword">where</span> <br>    customer_id <span class="hljs-keyword">in</span> <br>    (<br>        <span class="hljs-keyword">select</span> <br>        <span class="hljs-keyword">distinct</span> if(<span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> customer_id , c.product_key) <span class="hljs-operator">=</span> <br>        <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> p.product_key),customer_id,<span class="hljs-keyword">null</span>)   <br>        <span class="hljs-keyword">from</span> <br>            customer c <br>        <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span><br>            product p<br>        <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>            customer_id<br>    )<br>    <br>    <br><span class="hljs-keyword">select</span> <br>customer_id<br><span class="hljs-keyword">from</span><br>customer<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>customer_id<br><span class="hljs-keyword">having</span><br><span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span>(product_key))<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> product)<br></code></pre></td></tr></table></figure><h4 id="统计-和-union-all"><a href="#统计-和-union-all" class="headerlink" title="统计 和 union all"></a>统计 和 union all</h4><p><img src="D:\Study\求职\学习笔记\图片文件\U.png" alt="U"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>    <span class="hljs-string">&#x27;Low Salary&#x27;</span> <span class="hljs-keyword">as</span> category ,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) accounts_count<br><span class="hljs-keyword">from</span> <br>    accounts a1<br><span class="hljs-keyword">where</span> <br>    a1.income <span class="hljs-operator">&lt;</span> <span class="hljs-number">20000</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> <br>    <span class="hljs-string">&#x27;Average Salary&#x27;</span> <span class="hljs-keyword">as</span> category ,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) accounts_count<br><span class="hljs-keyword">from</span> <br>    accounts a2<br><span class="hljs-keyword">where</span> <br>    a2.income <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20000</span> <span class="hljs-keyword">and</span> a2.income <span class="hljs-operator">&lt;=</span> <span class="hljs-number">50000</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> <br>    <span class="hljs-string">&#x27;High Salary&#x27;</span> <span class="hljs-keyword">as</span> category ,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) accounts_count<br><span class="hljs-keyword">from</span> <br>    accounts a3<br><span class="hljs-keyword">where</span> <br>    a3.income <span class="hljs-operator">&gt;</span> <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><h4 id="多种条件筛选-临时表-union-all"><a href="#多种条件筛选-临时表-union-all" class="headerlink" title="多种条件筛选  临时表  union all"></a>多种条件筛选  临时表  union all</h4><p><img src="D:\Study\求职\学习笔记\图片文件\VG3.png" alt="VG3"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>    employee_id , department_id<br><span class="hljs-keyword">from</span> <br>    employee e1<br><span class="hljs-keyword">where</span> <br>    e1.primary_flag <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Y&#x27;</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> <br>    employee_id , department_id<br><span class="hljs-keyword">from</span> <br>    employee e2<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>    employee_id<br><span class="hljs-keyword">having</span> <br>    <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> employee_id<br><br><span class="hljs-keyword">with</span> t <span class="hljs-keyword">as</span>(<br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>,<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> employee_id) cnt<br>    <span class="hljs-keyword">from</span> Employee<br>)<br><span class="hljs-keyword">select</span> employee_id,department_id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> primary_flag<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Y&#x27;</span> <span class="hljs-keyword">or</span> cnt<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="使用group-by-max-min-达成最……的"><a href="#使用group-by-max-min-达成最……的" class="headerlink" title="使用group by + max min 达成最……的"></a>使用group by + max min 达成最……的</h4><p><img src="D:\Study\求职\学习笔记\图片文件\MC.png" alt="MC"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>    product_id <span class="hljs-keyword">as</span> product_id,<span class="hljs-number">10</span> <span class="hljs-keyword">as</span> price <br><span class="hljs-keyword">from</span> <br>    Products <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>    product_id<br><span class="hljs-keyword">having</span> <br>    <span class="hljs-built_in">min</span>(change_date)<span class="hljs-operator">&gt;</span><span class="hljs-string">&#x27;2019-08-16&#x27;</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> <br>product_id, new_price <span class="hljs-keyword">as</span> price <br><span class="hljs-keyword">from</span> products<br><span class="hljs-keyword">where</span> <br>    (product_id, change_date) <br>    <span class="hljs-keyword">in</span> (<br>        <span class="hljs-keyword">select</span> product_id, <span class="hljs-built_in">max</span>(change_date)<br>        <span class="hljs-keyword">from</span> products<br>        <span class="hljs-keyword">where</span> change_date <span class="hljs-operator">&lt;=</span> <span class="hljs-string">&#x27;2019-08-16&#x27;</span><br>        <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> product_id<br>    )<br><br><br></code></pre></td></tr></table></figure><h4 id="日期的格式处理-union-不能合并相同"><a href="#日期的格式处理-union-不能合并相同" class="headerlink" title="日期的格式处理,union 不能合并相同"></a>日期的格式处理,union 不能合并相同</h4><p><img src="D:\Study\求职\学习笔记\图片文件\58S2D.png" alt="58S2D"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">select</span> <br>    u.name <span class="hljs-keyword">as</span> results<br><span class="hljs-keyword">from</span> <br>    movierating m <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> users u <br>    <span class="hljs-keyword">on</span> <br>        m.user_id <span class="hljs-operator">=</span> u.user_id<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> m.user_id<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">desc</span> , u.name<br>limit <span class="hljs-number">1</span><br>)<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br>(<br><span class="hljs-keyword">select</span> i.title <span class="hljs-keyword">as</span> results<br><span class="hljs-keyword">from</span><br>    movierating m <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> movies i<br><span class="hljs-keyword">on</span> <br>    m.movie_id <span class="hljs-operator">=</span> i.movie_id<br><span class="hljs-keyword">where</span><br>    m.created_at <span class="hljs-keyword">like</span> &quot;2020-02%&quot;<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> m.movie_id<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">avg</span>(rating) <span class="hljs-keyword">desc</span>, i.title <br>limit <span class="hljs-number">1</span><br>)<br><br></code></pre></td></tr></table></figure><h4 id="窗口，使用子表，子表相连接"><a href="#窗口，使用子表，子表相连接" class="headerlink" title="窗口，使用子表，子表相连接"></a>窗口，使用子表，子表相连接</h4><p><img src="D:\Study\求职\学习笔记\图片文件\FEBGB.png" alt="FEBGB"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sql">#连接<br><span class="hljs-keyword">with</span> a1 <span class="hljs-keyword">as</span>(<br>    <span class="hljs-keyword">select</span> <br>        visited_on ,<span class="hljs-built_in">sum</span>(amount) amount<br>    <span class="hljs-keyword">from</span><br>        customer<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>    <br>        visited_on<br>)<br><span class="hljs-keyword">select</span> <br>    c1.visited_on ,<span class="hljs-built_in">sum</span>(c2.amount) amount , round(<span class="hljs-built_in">avg</span>(c2.amount) , <span class="hljs-number">2</span>) average_amount<br><span class="hljs-keyword">from</span> <br>    a1 c1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> a1 <span class="hljs-keyword">as</span> c2<br><span class="hljs-keyword">on</span>  <br>    datediff(c1.visited_on , c2.visited_on) <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">6</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>    <br>    c1.visited_on<br><span class="hljs-keyword">having</span><br>    <span class="hljs-built_in">count</span>(c2.visited_on) <span class="hljs-operator">=</span> <span class="hljs-number">7</span><br><br><br>#窗口<br><span class="hljs-keyword">with</span> t1 <span class="hljs-keyword">as</span> (<br>    <span class="hljs-keyword">select</span> visited_on,<span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">as</span> amount <br>    <span class="hljs-keyword">from</span> Customer<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> visited_on<br>)<br><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> visited_on,sum_amount <span class="hljs-keyword">as</span> amount,round(average_amount,<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> average_amount <br><span class="hljs-keyword">from</span><br>(<br>    <span class="hljs-keyword">select</span> visited_on,<br>        <span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> visited_on <span class="hljs-keyword">rows</span> <span class="hljs-number">6</span> preceding) <span class="hljs-keyword">as</span> sum_amount,<br>        <span class="hljs-built_in">avg</span>(amount) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> visited_on <span class="hljs-keyword">rows</span> <span class="hljs-number">6</span> preceding) <span class="hljs-keyword">as</span> average_amount<br>    <span class="hljs-keyword">from</span>  t1<br>)t2 <br><span class="hljs-keyword">where</span> datediff(visited_on,(<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(visited_on)<span class="hljs-keyword">from</span> Customer))<span class="hljs-operator">&gt;=</span><span class="hljs-number">6</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/05/hello-world/"/>
    <url>/2023/07/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>Hello World</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
